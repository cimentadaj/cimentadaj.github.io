<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on Jorge Cimentada</title>
    <link>https://cimentadaj.github.io/categories/r/</link>
    <description>Recent content in R on Jorge Cimentada</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sun, 08 Dec 2019 00:00:00 +0000</lastBuildDate>
    
    <atom:link href="https://cimentadaj.github.io/categories/r/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Locating parts of a string with `stringr`</title>
      <link>https://cimentadaj.github.io/blog/2019-12-08-locating-parts-of-a-string-with-stringr/locating-parts-of-a-string-with-stringr/</link>
      <pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cimentadaj.github.io/blog/2019-12-08-locating-parts-of-a-string-with-stringr/locating-parts-of-a-string-with-stringr/</guid>
      <description><![CDATA[
      


<p>I was wondering the realms of StackOver Flow answering some questions when I encoutered a question that looked to extract some parts of a string based on a regex. I thought I knew how to do this with the package <code>stringr</code> using, for example, <code>str_sub</code> but I found it a bit difficult to map how <code>str_locate</code> complements <code>str_sub</code>.</p>
<p><code>str_locate</code> and <code>str_locate_all</code> give back the locations of your regex inside the desired string as a <code>matrix</code> or a <code>list</code> respectively. However, that didn’t look very intuitive to pass on to <code>str_sub</code> which (I thought) only accepted numeric vectors with the indices of the parts of the strings that you want to extract. However, to my surprise, <code>str_sub</code> accepts not only numeric vectors but also a matrix with two columns, precisely the result of <code>str_locate</code>.</p>
<p>Let’s create a set of random strings from which we want to extract the word <code>special*word</code>, where <code>*</code> represents a random number.</p>
<pre class="r"><code>library(stringr)    

test_string &lt;-
  replicate(
    100,
    paste0(
      sample(c(letters, LETTERS, paste0(&quot;special&quot;, sample(1:10, 1),&quot;word&quot;)), 15),
      collapse = &quot;&quot;)
  )

head(test_string)</code></pre>
<pre><code>## [1] &quot;pZTQHcDVObnaCFS&quot;             &quot;qBxfbIHjauyEmgspecial10word&quot;
## [3] &quot;TKgbmQAEFoJHOVh&quot;             &quot;VoBdUAuzfPrmCGX&quot;            
## [5] &quot;dGgJOspecial5wordiFpbvXzUD&quot;  &quot;WOfLjNospecial4wordEeGkyTA&quot;</code></pre>
<p>Using <code>str_locate</code> returns a matrix with the positions of all matches for <strong>every string</strong>. This is what’s called <strong>vectorised</strong> functions in R.</p>
<pre class="r"><code>location_matrix &lt;-
  str_locate(test_string, pattern =  &quot;special[0-9]word&quot;)

head(location_matrix)</code></pre>
<pre><code>##      start end
## [1,]    NA  NA
## [2,]    NA  NA
## [3,]    NA  NA
## [4,]    NA  NA
## [5,]     6  17
## [6,]     8  19</code></pre>
<p>For this example this wouldn’t work, but I was also interested in checking how the result of <code>str_locate_all</code> would fit in this workflow. <code>str_locate_all</code> is the same as <code>str_locate</code> but since it can find <strong>more</strong> than one match per string, it returns a list with the same slots as there are strings in <code>test_string</code> with a matrix per slot showing the indices of the matches. Since many of the strings in <code>test_string</code> might not have <code>special*word</code>, we need to fill out those matches with <code>NA</code>:</p>
<pre class="r"><code>location_list &lt;-
  str_locate_all(test_string, pattern =  &quot;special[0-9]word&quot;) %&gt;% 
  lapply(function(.x) if (all(is.na(.x))) matrix(c(NA, NA), ncol = 2) else .x) %&gt;%
  {do.call(rbind, .)}

head(location_list)</code></pre>
<pre><code>##      start end
## [1,]    NA  NA
## [2,]    NA  NA
## [3,]    NA  NA
## [4,]    NA  NA
## [5,]     6  17
## [6,]     8  19</code></pre>
<p>Now that we have everything ready, <code>str_sub</code> can give our desires results using both numeric vectors as well as the entire matrix:</p>
<pre class="r"><code># Using numeric vectors from str_locate
str_sub(test_string, location_matrix[, 1], location_matrix[, 2])</code></pre>
<pre><code>##   [1] NA             NA             NA             NA             &quot;special5word&quot;
##   [6] &quot;special4word&quot; NA             NA             &quot;special5word&quot; NA            
##  [11] NA             NA             NA             NA             NA            
##  [16] NA             NA             NA             NA             NA            
##  [21] NA             NA             NA             &quot;special5word&quot; &quot;special6word&quot;
##  [26] NA             NA             NA             NA             NA            
##  [31] &quot;special4word&quot; NA             NA             NA             NA            
##  [36] NA             NA             NA             &quot;special7word&quot; NA            
##  [41] NA             NA             NA             NA             NA            
##  [46] NA             NA             NA             NA             NA            
##  [51] NA             NA             NA             NA             NA            
##  [56] NA             NA             NA             NA             NA            
##  [61] NA             NA             &quot;special4word&quot; NA             NA            
##  [66] NA             NA             NA             NA             NA            
##  [71] NA             NA             NA             &quot;special7word&quot; &quot;special9word&quot;
##  [76] NA             NA             NA             NA             NA            
##  [81] &quot;special4word&quot; NA             NA             &quot;special5word&quot; NA            
##  [86] NA             NA             NA             &quot;special9word&quot; &quot;special9word&quot;
##  [91] NA             NA             NA             NA             NA            
##  [96] &quot;special6word&quot; NA             NA             &quot;special3word&quot; &quot;special1word&quot;</code></pre>
<pre class="r"><code># Using numeric vectors from str_locate_all
str_sub(test_string, location_list[, 1], location_list[, 2])</code></pre>
<pre><code>##   [1] NA             NA             NA             NA             &quot;special5word&quot;
##   [6] &quot;special4word&quot; NA             NA             &quot;special5word&quot; NA            
##  [11] NA             NA             NA             NA             NA            
##  [16] NA             NA             NA             NA             NA            
##  [21] NA             NA             NA             &quot;special5word&quot; &quot;special6word&quot;
##  [26] NA             NA             NA             NA             NA            
##  [31] &quot;special4word&quot; NA             NA             NA             NA            
##  [36] NA             NA             NA             &quot;special7word&quot; NA            
##  [41] NA             NA             NA             NA             NA            
##  [46] NA             NA             NA             NA             NA            
##  [51] NA             NA             NA             NA             NA            
##  [56] NA             NA             NA             NA             NA            
##  [61] NA             NA             &quot;special4word&quot; NA             NA            
##  [66] NA             NA             NA             NA             NA            
##  [71] NA             NA             NA             &quot;special7word&quot; &quot;special9word&quot;
##  [76] NA             NA             NA             NA             NA            
##  [81] &quot;special4word&quot; NA             NA             &quot;special5word&quot; NA            
##  [86] NA             NA             NA             &quot;special9word&quot; &quot;special9word&quot;
##  [91] NA             NA             NA             NA             NA            
##  [96] &quot;special6word&quot; NA             NA             &quot;special3word&quot; &quot;special1word&quot;</code></pre>
<pre class="r"><code># Using the entire matrix
str_sub(test_string, location_matrix)</code></pre>
<pre><code>##   [1] NA             NA             NA             NA             &quot;special5word&quot;
##   [6] &quot;special4word&quot; NA             NA             &quot;special5word&quot; NA            
##  [11] NA             NA             NA             NA             NA            
##  [16] NA             NA             NA             NA             NA            
##  [21] NA             NA             NA             &quot;special5word&quot; &quot;special6word&quot;
##  [26] NA             NA             NA             NA             NA            
##  [31] &quot;special4word&quot; NA             NA             NA             NA            
##  [36] NA             NA             NA             &quot;special7word&quot; NA            
##  [41] NA             NA             NA             NA             NA            
##  [46] NA             NA             NA             NA             NA            
##  [51] NA             NA             NA             NA             NA            
##  [56] NA             NA             NA             NA             NA            
##  [61] NA             NA             &quot;special4word&quot; NA             NA            
##  [66] NA             NA             NA             NA             NA            
##  [71] NA             NA             NA             &quot;special7word&quot; &quot;special9word&quot;
##  [76] NA             NA             NA             NA             NA            
##  [81] &quot;special4word&quot; NA             NA             &quot;special5word&quot; NA            
##  [86] NA             NA             NA             &quot;special9word&quot; &quot;special9word&quot;
##  [91] NA             NA             NA             NA             NA            
##  [96] &quot;special6word&quot; NA             NA             &quot;special3word&quot; &quot;special1word&quot;</code></pre>
<p>A much easier approach to doing the above (which is cumbersome and verbose) is to use <code>str_extract</code>:</p>
<pre class="r"><code>str_extract(test_string, &quot;special[0-9]word&quot;)</code></pre>
<pre><code>##   [1] NA             NA             NA             NA             &quot;special5word&quot;
##   [6] &quot;special4word&quot; NA             NA             &quot;special5word&quot; NA            
##  [11] NA             NA             NA             NA             NA            
##  [16] NA             NA             NA             NA             NA            
##  [21] NA             NA             NA             &quot;special5word&quot; &quot;special6word&quot;
##  [26] NA             NA             NA             NA             NA            
##  [31] &quot;special4word&quot; NA             NA             NA             NA            
##  [36] NA             NA             NA             &quot;special7word&quot; NA            
##  [41] NA             NA             NA             NA             NA            
##  [46] NA             NA             NA             NA             NA            
##  [51] NA             NA             NA             NA             NA            
##  [56] NA             NA             NA             NA             NA            
##  [61] NA             NA             &quot;special4word&quot; NA             NA            
##  [66] NA             NA             NA             NA             NA            
##  [71] NA             NA             NA             &quot;special7word&quot; &quot;special9word&quot;
##  [76] NA             NA             NA             NA             NA            
##  [81] &quot;special4word&quot; NA             NA             &quot;special5word&quot; NA            
##  [86] NA             NA             NA             &quot;special9word&quot; &quot;special9word&quot;
##  [91] NA             NA             NA             NA             NA            
##  [96] &quot;special6word&quot; NA             NA             &quot;special3word&quot; &quot;special1word&quot;</code></pre>
<p>However, the whole objecive behind this exercise was to clearly map out how to connect <code>str_locate</code> to <code>str_sub</code> and it’s much clearer if you can pass the entire matrix. However, converting <code>str_locate_all</code> is still a bit tricky.</p>
]]>
      </description>
    </item>
    
    <item>
      <title>essurvey release</title>
      <link>https://cimentadaj.github.io/blog/2019-11-15-release-essurvey/essurvey-release/</link>
      <pubDate>Sat, 16 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cimentadaj.github.io/blog/2019-11-15-release-essurvey/essurvey-release/</guid>
      <description><![CDATA[
      


<p>The new <code>essurvey</code> 1.0.3 is here! This release is mainly about downloading weight data from the European Social Survey (ESS), which <a href="https://github.com/ropensci/essurvey/issues/9">has been on the works since</a> 2017! As usual, you can install from CRAN or Github with:</p>
<pre class="r"><code># From CRAN
install.packages(&quot;essurvey&quot;)

# or development version from Github
devtools::install_github(&quot;ropensci/essurvey&quot;)

# and load
library(essurvey)
set_email(&quot;your@email.com&quot;)</code></pre>
<p>Remember to set your registered email with <code>set_email</code> to download ESS data. This is as easy as running <code>set_email("your@email.com")</code>, with your email. The package now has two main functions to download weight data (called SDDF by the ESS): <code>show_sddf_cntrounds</code> and <code>import_sddf_country</code>. The first one returns the available weight rounds for a specific country. For example, for which rounds does Italy have weight data?</p>
<pre class="r"><code>ita_rnds &lt;- show_sddf_cntrounds(&quot;Italy&quot;)

ita_rnds</code></pre>
<pre><code>## [1] 6 8</code></pre>
<p>How about Germany?</p>
<pre class="r"><code>show_sddf_cntrounds(&quot;Germany&quot;)</code></pre>
<pre><code>## [1] 1 2 3 4 5 6 7 8</code></pre>
<p>For some rounds, some countries used complete random sampling, so they didn’t need any weight data for correct estimation. Italy did not use a random sample for round 8 so let’s focus on that wave for the example. To actually download this round, we use <code>import_sddf_country</code>:</p>
<pre class="r"><code># Download weight data
ita_dt &lt;- import_sddf_country(&quot;Italy&quot;, 8)

ita_dt</code></pre>
<pre><code>## # A tibble: 2,626 x 10
##    name  essround edition proddate cntry  idno   psu domain stratum    prob
##    &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
##  1 ESS8…        8 1.2     11.02.2… IT        1 11029      2     658 1.01e-4
##  2 ESS8…        8 1.2     11.02.2… IT        2 11170      2     665 1.11e-4
##  3 ESS8…        8 1.2     11.02.2… IT        4 11127      2     660 1.03e-4
##  4 ESS8…        8 1.2     11.02.2… IT        5 10771      2     671 1.04e-4
##  5 ESS8…        8 1.2     11.02.2… IT        6 11148      2     666 1.06e-4
##  6 ESS8…        8 1.2     11.02.2… IT        9 11163      1     667 1.05e-4
##  7 ESS8…        8 1.2     11.02.2… IT       14 11183      1     657 1.06e-4
##  8 ESS8…        8 1.2     11.02.2… IT       15 11184      2     661 9.97e-5
##  9 ESS8…        8 1.2     11.02.2… IT       16 10928      2     652 1.01e-4
## 10 ESS8…        8 1.2     11.02.2… IT       22 11171      2     664 9.97e-5
## # … with 2,616 more rows</code></pre>
<p>Notice that the weight data has an <code>idno</code> column. This column can be used to match each respondent from each country to the main ESS data. This means that you can now actually do proper weighted analysis using the ESS data on the fly! How would we match the data for Italy, for example?</p>
<p>We download the main data:</p>
<pre class="r"><code>library(dplyr)

# Download main data
ita_main &lt;- import_country(&quot;Italy&quot;, 8)</code></pre>
<p>And then merge it with the weight data:</p>
<pre class="r"><code># Let&#39;s keep only the important weight columns
ita_dt &lt;- ita_dt %&gt;% select(idno, psu, domain, stratum, prob)

# Merged main data and weight data
complete_data &lt;- inner_join(ita_main, ita_dt, by = &quot;idno&quot;)</code></pre>
<pre><code>## Warning: Column `idno` has different attributes on LHS and RHS of join</code></pre>
<pre class="r"><code># There we have the matched data
complete_data %&gt;%
  select(essround, idno, cntry, psu, stratum, prob)</code></pre>
<pre><code>## # A tibble: 2,626 x 6
##    essround  idno cntry   psu stratum      prob
##       &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;
##  1        8     1 IT    11029     658 0.000101 
##  2        8     2 IT    11170     665 0.000111 
##  3        8     4 IT    11127     660 0.000103 
##  4        8     5 IT    10771     671 0.000104 
##  5        8     6 IT    11148     666 0.000106 
##  6        8     9 IT    11163     667 0.000105 
##  7        8    14 IT    11183     657 0.000106 
##  8        8    15 IT    11184     661 0.0000997
##  9        8    16 IT    10928     652 0.000101 
## 10        8    22 IT    11171     664 0.0000997
## # … with 2,616 more rows</code></pre>
<p>There we have the matched data! This can be easily piped to the <code>survey</code> package and perform properly weighted analysis of the ESS data. In fact, an official ESS package for analyzing data is something we’re thinking of developing to making analyzing ESS data very easy.</p>
<p>Weight data (or SDDF data) is a bit tricky because not all country/rounds data have the same extension (some have SPSS, some have Stata, etc..) nor the same format (number of columns, name of columns, etc..). We would appreciate if you can submit any errors you find on <a href="https://github.com/ropensci/essurvey/issues">Github</a> and we’ll try taking care of them as soon as possible.</p>
<p>Special thanks to <a href="https://twitter.com/phnk?lang=en">phnk</a>, <a href="https://twitter.com/djhurio/">djhurio</a> and Stefan Zins for helping out to push this.</p>
<p>Enjoy this new release!</p>
]]>
      </description>
    </item>
    
    <item>
      <title>Saving missing categories from R to Stata</title>
      <link>https://cimentadaj.github.io/blog/2019-03-16-saving-missing-categories-from-r-to-stata/saving-missing-categories-from-r-to-stata/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cimentadaj.github.io/blog/2019-03-16-saving-missing-categories-from-r-to-stata/saving-missing-categories-from-r-to-stata/</guid>
      <description><![CDATA[
      


<p>I’m finishing a project from the RECSM institute where we developed a <a href="https://essurvey.shinyapps.io/ess_castellano/">Shiny application</a> to download data from the European Social Survey with Spanish translated labels. This was one hell of a project since I had to build some wrappers around the Google Translate API to generate translations for over 1300 questions and stream line this to be interactive while users download the data. That’s a long story which I will not delve into.</p>
<p>This post is about a bug I found in the <code>haven</code> package while doing the project. The bug is simple to explain and <a href="https://github.com/tidyverse/haven/issues/435">I filed it in <code>haven</code> already</a>:</p>
<p>Let’s define a labelled double with only one tagged NA value.</p>
<pre class="r"><code>library(haven)
#&gt; Warning: package &#39;haven&#39; was built under R version 3.4.4

tst &lt;-
  labelled(
    c(
      1:5,
      tagged_na(&quot;d&quot;)
    ),
    c(
      &quot;Agree Strongly&quot; = 1,
      &quot;Agree&quot; = 2,
      &quot;Neither agree nor disagree&quot; = 3,
      &quot;Disagree&quot; = 4,
      &quot;Disagree strongly&quot; = 5,
      &quot;No answer&quot; = tagged_na(&quot;d&quot;)
    )
  )

tst</code></pre>
<pre><code>## &lt;Labelled double&gt;
## [1]     1     2     3     4     5 NA(d)
## 
## Labels:
##  value                      label
##      1             Agree Strongly
##      2                      Agree
##      3 Neither agree nor disagree
##      4                   Disagree
##      5          Disagree strongly
##  NA(d)                  No answer</code></pre>
<pre class="r"><code>write_dta(data.frame(freehms = tst), &quot;test.dta&quot;, version = 13)</code></pre>
<p>If I load this in Stata and type tab freehms, all labels are correct:</p>
<p><img src="/img/stata1.png" /></p>
<p>Now, if I take the code above and add another tagged NA value, then <code>write_dta</code> drops the last label for some reason:</p>
<pre class="r"><code>library(haven)

tst &lt;-
  labelled(c(1:5,
             tagged_na(&#39;d&#39;),
             ## Only added this
             tagged_na(&#39;c&#39;)
          ),
        c(&#39;Agree Strongly&#39; = 1,
          &#39;Agree&#39; = 2,
          &#39;Neither agree nor disagree&#39; = 3,
          &#39;Disagree&#39; = 4,
          &#39;Disagree strongly&#39; = 5,
          &#39;No answer&#39; = tagged_na(&#39;d&#39;),
            ## And this
          &#39;Dont know&#39; = tagged_na(&#39;c&#39;)
          )
        )

tst</code></pre>
<pre><code>## &lt;Labelled double&gt;
## [1]     1     2     3     4     5 NA(d) NA(c)
## 
## Labels:
##  value                      label
##      1             Agree Strongly
##      2                      Agree
##      3 Neither agree nor disagree
##      4                   Disagree
##      5          Disagree strongly
##  NA(d)                  No answer
##  NA(c)                  Dont know</code></pre>
<pre class="r"><code>write_dta(data.frame(freehms = tst), &quot;test.dta&quot;, version = 13)</code></pre>
<p><img src="/img/stata2.png" /></p>
<p>Well, the bug is evident (notice the 5 without a label?). However, since the project is on a deadline I had to come up with a solution. It’s very simple: avoid tagged NA’s but recode them as traditional labels. Here’s a solution:</p>
<pre class="r"><code>library(sjlabelled)
library(sjmisc)

# Labels tags present in the ESS data
old_label_names &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)

# Grab the labels with tagged NA&#39;s with a regex
na_available &lt;- unname(gsub(&quot;NA|\\(|\\)&quot;, &quot;&quot;, get_na(tst, TRUE)))

# Identify which of the existent labels are actually valid ESS missings
which_ones_use &lt;- old_label_names %in% na_available

# Subset only the ones which need recoding
value_code &lt;- c(666, 777, 888, 999)[which_ones_use]
new_label_names &lt;- c(&quot;.a&quot;, &quot;.b&quot;, &quot;.c&quot;, &quot;.d&quot;)[which_ones_use]

# Recode them
for (i in seq_along(na_available)) {
  tst &lt;- replace_na(tst,
                    value = value_code[i],
                    na.label = new_label_names[i],
                    tagged.na = na_available[i]
                    )
}

tst</code></pre>
<pre><code>## &lt;Labelled double&gt;
## [1]   1   2   3   4   5 888 999
## 
## Labels:
##  value                      label
##      1             Agree Strongly
##      2                      Agree
##      3 Neither agree nor disagree
##      4                   Disagree
##      5          Disagree strongly
##    888                         .c
##    999                         .d</code></pre>
<p>There we go. Those labels would clearly be interpreted as missings and Stata would read them as traditional labels (well, it’s not perfect, but it’s a workaround). What I did was wrap the above code into a function and apply it to all questions in all rounds (&gt; 1300!).</p>
<pre class="r"><code>recode_stata_labels &lt;- function(x) {
  # Labels tags present in the ESS data
  old_label_names &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)

  # Grab the labels with tagged NA&#39;s with a regex
  na_available &lt;- unname(gsub(&quot;NA|\\(|\\)&quot;, &quot;&quot;, get_na(x, TRUE)))

  # Identify which of the existent labels are actually valid ESS missings
  which_ones_use &lt;- old_label_names %in% na_available

  # Subset only the ones which need recoding
  value_code &lt;- c(666, 777, 888, 999)[which_ones_use]
  new_label_names &lt;- c(&quot;.a&quot;, &quot;.b&quot;, &quot;.c&quot;, &quot;.d&quot;)[which_ones_use]

  for (i in seq_along(na_available)) {
    x &lt;- replace_na(x,
                    value = value_code[i],
                    na.label = new_label_names[i],
                    tagged.na = na_available[i]
    )
  }

  x
}</code></pre>
<p>Now, what happens if a <code>labelled</code> class only has tagged NA’s?</p>
<pre class="r"><code>tst &lt;-
  labelled(c(1:5,
             tagged_na(&#39;d&#39;),
             tagged_na(&#39;c&#39;)
             ),
           c(&#39;No answer&#39; = tagged_na(&#39;d&#39;), &#39;Dont know&#39; = tagged_na(&#39;c&#39;)))

tst</code></pre>
<pre><code>## &lt;Labelled double&gt;
## [1]     1     2     3     4     5 NA(d) NA(c)
## 
## Labels:
##  value     label
##  NA(d) No answer
##  NA(c) Dont know</code></pre>
<pre class="r"><code>recode_stata_labels(tst)</code></pre>
<pre><code>## Error: `x` must be a double vector</code></pre>
<p>That’s weird. I was in such a rush that I didn’t really want to debug the source code in <code>haven</code>. However, I had the intuition that this was related to the fact that there were only tagged NA’s as labels. How do I fixed it? Just add a toy label at the beginning of the function and remove it after the recoding.</p>
<pre class="r"><code>recode_stata_labels &lt;- function(x) {
    # I add a random label (here) and delete it at the end (end of the function)
    x &lt;- add_labels(x, labels = c(&#39;test&#39; = 111111))

    # Note that this vector is in the same order as the `value_code` and `new_label_names`
    # because they&#39;re values correspond to each other in this order.
    old_label_names &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)

    na_available &lt;- unname(gsub(&quot;NA|\\(|\\)&quot;, &quot;&quot;, sjlabelled::get_na(x, TRUE)))
    which_ones_use &lt;- old_label_names %in% na_available

    value_code &lt;- c(666, 777, 888, 999)[which_ones_use]
    new_label_names &lt;- c(&quot;.a&quot;, &quot;.b&quot;, &quot;.c&quot;, &quot;.d&quot;)[which_ones_use]

    for (i in seq_along(na_available)) {
      x &lt;- replace_na(x, value = value_code[i], na.label = new_label_names[i], tagged.na = na_available[i])
    }

    x &lt;- remove_labels(x, labels = &quot;test&quot;)

  x
}

recode_stata_labels(tst)</code></pre>
<pre><code>## &lt;Labelled double&gt;
## [1]   1   2   3   4   5 888 999
## 
## Labels:
##  value label
##    888    .c
##    999    .d</code></pre>
<p>There we are. The <code>replace_na</code> function is actually doing most of the work and I found it extremely useful (comes from the <code>sjmisc</code> package).</p>
]]>
      </description>
    </item>
    
    <item>
      <title>Why does R drop attributes when subsetting?</title>
      <link>https://cimentadaj.github.io/blog/2019-03-17-why-does-r-drop-attributes-when-subsetting/one-thing-i-hate-about-r/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cimentadaj.github.io/blog/2019-03-17-why-does-r-drop-attributes-when-subsetting/one-thing-i-hate-about-r/</guid>
      <description><![CDATA[
      


<p>I had to spend about 1 hour yesterday because R did something completely unpredictable (for my taste). It dropped an attribute without a warning.</p>
<pre class="r"><code>df &lt;- data.frame(x = rep(c(1, 2), 20))

attr(df$x, &quot;label&quot;) &lt;- &quot;This is clearly a label&quot;

df$x</code></pre>
<pre><code>##  [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1
## [36] 2 1 2 1 2
## attr(,&quot;label&quot;)
## [1] &quot;This is clearly a label&quot;</code></pre>
<p>The label is clearly there. To my surprise, if I subset this data frame, R drops the attribute.</p>
<pre class="r"><code>new_df &lt;- df[df$x == 2, , drop = FALSE]

new_df$x</code></pre>
<pre><code>##  [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2</code></pre>
<p>It doesn’t matter if it’s using bracket subsetting (<code>[</code>) or <code>subset</code>.</p>
<pre class="r"><code>new_df &lt;- subset(df, x == 2)

new_df$x</code></pre>
<pre><code>##  [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2</code></pre>
<p>That’s not good. R’s dropping attributes silently. For my specific purpose I ended up using <code>dplyr::filter</code> which safely enough preserves attributes.</p>
<pre class="r"><code>library(dplyr)

df %&gt;% 
  filter(df, x == 2) %&gt;% 
  pull(x)</code></pre>
<pre><code>##  [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
## attr(,&quot;label&quot;)
## [1] &quot;This is clearly a label&quot;</code></pre>
]]>
      </description>
    </item>
    
  </channel>
</rss>
